"""Firestore utility functions for Firebase initialization and client management."""

import datetime
import os
from typing import Optional, Any

import click
import firebase_admin
from firebase_admin import credentials, firestore
from pydantic import BaseModel

# Define the name of the environment variable for the key path
SERVICE_ACCOUNT_KEY_ENV_VAR = 'FIREBASE_SERVICE_ACCOUNT_KEY_PATH'

# Global variable for the Firestore database client
# This helps to reuse the initialized client within the same process/session
_db_client: Optional[Any] = None


def get_firestore_client(key_path: Optional[str] = None) -> Optional[Any]:
    """Initialize Firebase Admin SDK and return a Firestore client.
    
    Reuses an existing client if one has already been initialized by this function.
    Handles Firebase app initialization and credential management.
    
    Args:
        key_path: Path to the Firebase service account key JSON file.
                 If None, tries to use FIREBASE_SERVICE_ACCOUNT_KEY_PATH env var.
                 
    Returns:
        Initialized Firestore client, or None if initialization fails.
        
    Raises:
        ValueError: If the service account key file is invalid.
        FileNotFoundError: If the key file path doesn't exist.
    """
    global _db_client
    if _db_client is not None:
        return _db_client

    effective_key_path = key_path or os.environ.get(SERVICE_ACCOUNT_KEY_ENV_VAR)

    if not effective_key_path:
        click.echo(
            f"Error: Firebase service account key path is required. "
            f"Set the {SERVICE_ACCOUNT_KEY_ENV_VAR} environment variable or provide the --key-path argument.",
            err=True
        )
        return None

    if not os.path.exists(effective_key_path):
        click.echo(f"Error: Service account key file not found at path: {effective_key_path}", err=True)
        return None

    try:
        cred = credentials.Certificate(effective_key_path)
        # Initialize the app only if it hasn't been initialized elsewhere.
        # This check is robust for various scenarios (e.g., running multiple commands in one script).
        if not firebase_admin._apps:
            firebase_admin.initialize_app(cred)
        # If an app IS initialized, we assume it's the one we want to use,
        # and firestore.client() will use it.
        
        _db_client = firestore.client()
        return _db_client
    except ValueError as ve:  # Often indicates a problem with the key file itself
        click.echo(f"Error initializing Firebase with key file {effective_key_path}. "
                   f"Is it a valid JSON key file? Details: {ve}", err=True)
        return None
    except Exception as e:
        click.echo(f"An unexpected error occurred during Firebase initialization: {e}", err=True)
        return None


def validate_db_client(db: Any, ctx: click.Context) -> None:
    """Validate that database client exists and exit if not.
    
    Args:
        db: Firestore database client to validate
        ctx: Click context for exiting on error
        
    Returns:
        None
        
    Raises:
        SystemExit: If database client is None or invalid
    """
    if not db:
        click.echo("Database client not found.", err=True)
        ctx.exit(1)


def parse_publication_date(date_str: str) -> Optional[str]:
    """Parse and validate publication date string.
    
    Args:
        date_str: Date string in YYYY-MM-DD format
        
    Returns:
        Validated date string if valid, None if invalid
        
    Raises:
        None - Invalid dates return None rather than raising
    """
    if not date_str:
        return None
        
    try:
        datetime.datetime.strptime(date_str, '%Y-%m-%d')
        return date_str
    except ValueError:
        click.echo(f"Warning: Date '{date_str}' is not in YYYY-MM-DD format.", err=True)
        return None


def check_article_exists(db: Any, article_id: str) -> tuple[bool, Optional[Any]]:
    """Check if article exists in Firestore.
    
    Args:
        db: Firestore database client
        article_id: Unique identifier of the article
        
    Returns:
        Tuple of (exists: bool, document: Optional[DocumentSnapshot])
        
    Raises:
        Exception: If Firestore query fails
    """
    article_ref = db.collection('articles').document(article_id)
    article_doc = article_ref.get()
    return article_doc.exists, article_doc if article_doc.exists else None


def add_document_to_collection(db: Any, collection_name: str, data: BaseModel) -> Optional[str]:
    """Adds a Pydantic model's data as a new document to a Firestore collection.

    The document ID will be auto-generated by Firestore.

    Args:
        db: Initialized Firestore client.
        collection_name: Name of the collection to add the document to.
        data: A Pydantic BaseModel instance containing the data for the document.

    Returns:
        The ID of the newly created document if successful, otherwise None.
    """
    if not db:
        click.echo("Error: Firestore client is not initialized.", err=True)
        return None
    if not collection_name:
        click.echo("Error: Collection name cannot be empty.", err=True)
        return None
    if not isinstance(data, BaseModel):
        click.echo("Error: Data must be a Pydantic BaseModel instance.", err=True)
        return None

    try:
        # Convert Pydantic model to dict for Firestore
        # model_dump() is for Pydantic V2
        document_data = data.model_dump(mode='json') # Use mode='json' for types like datetime

        # Add a new document with an auto-generated ID
        doc_ref = db.collection(collection_name).add(document_data)
        
        # Firestore's add() method returns a tuple: (timestamp, DocumentReference)
        # We want the ID of the new document from the DocumentReference
        new_doc_id = doc_ref[1].id
        click.echo(f"Document successfully added to '{collection_name}' with ID: {new_doc_id}")
        return new_doc_id
    except Exception as e:
        click.echo(f"Error adding document to collection '{collection_name}': {e}", err=True)
        return None


if __name__ == '__main__':
    # Example usage (for testing this module directly)
    # You would need to set the environment variable or pass a path
    # export FIREBASE_SERVICE_ACCOUNT_KEY_PATH="/path/to/your/serviceAccountKey.json"
    # python english-language-helper/cli/firestore_utils.py
    
    print("Attempting to get Firestore client (ensure env var is set or modify for direct test)...")
    # For direct testing, you might want to provide a path if the env var isn't set globally
    # test_key_path = "/path/to/your/serviceAccountKey.json" 
    # client = get_firestore_client(key_path=test_key_path)
    client = get_firestore_client()  # Relies on env var for this simple test
    
    if client:
        print("Successfully obtained Firestore client.")
        # You could add a simple test query here if needed, e.g., list collections
        try:
            collections = [col.id for col in client.collections()]
            print(f"Available collections: {collections}")

            # Example of using add_document_to_collection
            class MyTestData(BaseModel):
                name: str
                value: int
                created: datetime.datetime

            test_data_item = MyTestData(name="Test Item", value=123, created=datetime.datetime.now(datetime.timezone.utc))
            
            print(f"\nAttempting to add test document to 'test_collection'...")
            new_id = add_document_to_collection(client, "test_collection", test_data_item)
            if new_id:
                print(f"Test document added with ID: {new_id}")
                # Optional: verify by fetching (not implemented here to keep example simple)
            else:
                print("Failed to add test document.")

        except Exception as e:
            print(f"Error during __main__ test operations: {e}")
    else:
        print("Failed to obtain Firestore client. Check service account key path and permissions.")